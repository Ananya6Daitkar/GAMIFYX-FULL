import { Pool } from 'pg';
import axios from 'axios';
import { 
  Vulnerability, 
  VulnerabilitySeverity, 
  VulnerabilityStatus,
  SecurityAlert,
  AlertType,
  AlertSeverity,
  AlertStatus
} from '@/models/Security';
import { logger } from '@/telemetry/logger';
import { metrics } from '@opentelemetry/api';
import pool from '@/database/connection';

const meter = metrics.getMeter('security-dashboard', '1.0.0');

// Vulnerability metrics
const vulnerabilityScans = meter.createCounter('vulnerability_scans_total', {
  description: 'Total vulnerability scans performed'
});

const vulnerabilitiesFound = meter.createCounter('vulnerabilities_found_total', {
  description: 'Total vulnerabilities found by severity'
});

const vulnerabilitiesResolved = meter.createCounter('vulnerabilities_resolved_total', {
  description: 'Total vulnerabilities resolved'
});

export class VulnerabilityService {
  private pool: Pool;
  private trivyApiUrl: string;
  private snykApiUrl: string;
  private snykApiToken: string;

  constructor(dbPool: Pool = pool) {
    this.pool = dbPool;
    this.trivyApiUrl = process.env.TRIVY_API_URL || 'http://localhost:8080';
    this.snykApiUrl = process.env.SNYK_API_URL || 'https://api.snyk.io/v1';
    this.snykApiToken = process.env.SNYK_API_TOKEN || '';
  }

  async scanRepository(repositoryUrl: string, branch: string = 'main'): Promise<Vulnerability[]> {
    vulnerabilityScans.add(1, { source: 'trivy', type: 'repository' });

    try {
      logger.info('Starting repository vulnerability scan', { repositoryUrl, branch });

      // Simulate Trivy scan (in real implementation, this would call Trivy API)
      const vulnerabilities = await this.performTrivyScan(repositoryUrl, branch);

      // Store vulnerabilities in database
      for (const vuln of vulnerabilities) {
        await this.storeVulnerability(vuln);
      }

      // Create alerts for critical and high severity vulnerabilities
      await this.createVulnerabilityAlerts(vulnerabilities);

      vulnerabilitiesFound.add(vulnerabilities.length, { source: 'trivy' });

      logger.info('Repository vulnerability scan completed', { 
        repositoryUrl, 
        vulnerabilitiesFound: vulnerabilities.length 
      });

      return vulnerabilities;

    } catch (error) {
      logger.error('Repository vulnerability scan failed', { error, repositoryUrl });
      throw error;
    }
  }

  async scanContainer(imageTag: string): Promise<Vulnerability[]> {
    vulnerabilityScans.add(1, { source: 'trivy', type: 'container' });

    try {
      logger.info('Starting container vulnerability scan', { imageTag });

      // Simulate container scan
      const vulnerabilities = await this.performContainerScan(imageTag);

      // Store vulnerabilities
      for (const vuln of vulnerabilities) {
        await this.storeVulnerability(vuln);
      }

      await this.createVulnerabilityAlerts(vulnerabilities);

      vulnerabilitiesFound.add(vulnerabilities.length, { source: 'trivy' });

      logger.info('Container vulnerability scan completed', { 
        imageTag, 
        vulnerabilitiesFound: vulnerabilities.length 
      });

      return vulnerabilities;

    } catch (error) {
      logger.error('Container vulnerability scan failed', { error, imageTag });
      throw error;
    }
  }

  async scanDependencies(projectPath: string): Promise<Vulnerability[]> {
    vulnerabilityScans.add(1, { source: 'snyk', type: 'dependencies' });

    try {
      logger.info('Starting dependency vulnerability scan', { projectPath });

      // Simulate Snyk scan
      const vulnerabilities = await this.performSnykScan(projectPath);

      // Store vulnerabilities
      for (const vuln of vulnerabilities) {
        await this.storeVulnerability(vuln);
      }

      await this.createVulnerabilityAlerts(vulnerabilities);

      vulnerabilitiesFound.add(vulnerabilities.length, { source: 'snyk' });

      logger.info('Dependency vulnerability scan completed', { 
        projectPath, 
        vulnerabilitiesFound: vulnerabilities.length 
      });

      return vulnerabilities;

    } catch (error) {
      logger.error('Dependency vulnerability scan failed', { error, projectPath });
      throw error;
    }
  }

  private async performTrivyScan(repositoryUrl: string, branch: string): Promise<Vulnerability[]> {
    // Simulate Trivy scan results
    const mockVulnerabilities: Vulnerability[] = [
      {
        id: `vuln-${Date.now()}-1`,
        cveId: 'CVE-2023-12345',
        title: 'SQL Injection vulnerability in user authentication',
        description: 'A SQL injection vulnerability exists in the user authentication module that could allow attackers to bypass authentication.',
        severity: VulnerabilitySeverity.HIGH,
        cvssScore: 8.1,
        component: 'auth-service',
        version: '1.2.3',
        fixedVersion: '1.2.4',
        discoveredAt: new Date(),
        status: VulnerabilityStatus.OPEN,
        source: 'trivy',
        references: [
          'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-12345',
          'https://github.com/advisories/GHSA-xxxx-yyyy-zzzz'
        ]
      },
      {
        id: `vuln-${Date.now()}-2`,
        cveId: 'CVE-2023-67890',
        title: 'Cross-site scripting (XSS) in dashboard component',
        description: 'A reflected XSS vulnerability in the dashboard component could allow attackers to execute malicious scripts.',
        severity: VulnerabilitySeverity.MEDIUM,
        cvssScore: 6.1,
        component: 'dashboard-frontend',
        version: '2.1.0',
        fixedVersion: '2.1.1',
        discoveredAt: new Date(),
        status: VulnerabilityStatus.OPEN,
        source: 'trivy',
        references: [
          'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-67890'
        ]
      }
    ];

    // In real implementation, this would call Trivy API
    // const response = await axios.post(`${this.trivyApiUrl}/scan`, {
    //   repository: repositoryUrl,
    //   branch: branch
    // });

    return mockVulnerabilities;
  }

  private async performContainerScan(imageTag: string): Promise<Vulnerability[]> {
    // Simulate container scan results
    const mockVulnerabilities: Vulnerability[] = [
      {
        id: `vuln-${Date.now()}-3`,
        cveId: 'CVE-2023-11111',
        title: 'Buffer overflow in base image library',
        description: 'A buffer overflow vulnerability in the base image library could lead to remote code execution.',
        severity: VulnerabilitySeverity.CRITICAL,
        cvssScore: 9.8,
        component: 'base-image',
        version: 'ubuntu:20.04',
        fixedVersion: 'ubuntu:20.04.1',
        discoveredAt: new Date(),
        status: VulnerabilityStatus.OPEN,
        source: 'trivy',
        references: [
          'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-11111'
        ]
      }
    ];

    return mockVulnerabilities;
  }

  private async performSnykScan(projectPath: string): Promise<Vulnerability[]> {
    // Simulate Snyk scan results
    const mockVulnerabilities: Vulnerability[] = [
      {
        id: `vuln-${Date.now()}-4`,
        title: 'Prototype pollution in lodash',
        description: 'A prototype pollution vulnerability in lodash could allow attackers to modify object prototypes.',
        severity: VulnerabilitySeverity.MEDIUM,
        cvssScore: 5.6,
        component: 'lodash',
        version: '4.17.20',
        fixedVersion: '4.17.21',
        discoveredAt: new Date(),
        status: VulnerabilityStatus.OPEN,
        source: 'snyk',
        references: [
          'https://snyk.io/vuln/SNYK-JS-LODASH-1018905'
        ]
      }
    ];

    return mockVulnerabilities;
  }

  private async storeVulnerability(vulnerability: Vulnerability): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      const query = `
        INSERT INTO vulnerabilities (
          id, cve_id, title, description, severity, cvss_score, component, version, 
          fixed_version, discovered_at, status, source, references
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        ON CONFLICT (id) DO UPDATE SET
          status = EXCLUDED.status,
          assigned_to = EXCLUDED.assigned_to,
          resolved_at = EXCLUDED.resolved_at,
          resolution_notes = EXCLUDED.resolution_notes
      `;

      const values = [
        vulnerability.id,
        vulnerability.cveId,
        vulnerability.title,
        vulnerability.description,
        vulnerability.severity,
        vulnerability.cvssScore,
        vulnerability.component,
        vulnerability.version,
        vulnerability.fixedVersion,
        vulnerability.discoveredAt,
        vulnerability.status,
        vulnerability.source,
        JSON.stringify(vulnerability.references)
      ];

      await client.query(query, values);

    } catch (error) {
      logger.error('Failed to store vulnerability', { error, vulnerabilityId: vulnerability.id });
      throw error;
    } finally {
      client.release();
    }
  }

  private async createVulnerabilityAlerts(vulnerabilities: Vulnerability[]): Promise<void> {
    const criticalAndHigh = vulnerabilities.filter(v => 
      v.severity === VulnerabilitySeverity.CRITICAL || v.severity === VulnerabilitySeverity.HIGH
    );

    for (const vuln of criticalAndHigh) {
      const alert: SecurityAlert = {
        id: `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: AlertType.VULNERABILITY,
        severity: vuln.severity === VulnerabilitySeverity.CRITICAL ? AlertSeverity.CRITICAL : AlertSeverity.HIGH,
        title: `${vuln.severity.toUpperCase()} Vulnerability: ${vuln.title}`,
        description: `${vuln.description}\n\nComponent: ${vuln.component} v${vuln.version}\nCVSS Score: ${vuln.cvssScore}`,
        source: vuln.source,
        timestamp: new Date(),
        status: AlertStatus.OPEN,
        metadata: {
          vulnerabilityId: vuln.id,
          cveId: vuln.cveId,
          component: vuln.component,
          version: vuln.version,
          fixedVersion: vuln.fixedVersion,
          cvssScore: vuln.cvssScore
        }
      };

      await this.storeAlert(alert);
    }
  }

  private async storeAlert(alert: SecurityAlert): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      const query = `
        INSERT INTO security_alerts (
          id, type, severity, title, description, source, timestamp, status, metadata
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      `;

      const values = [
        alert.id,
        alert.type,
        alert.severity,
        alert.title,
        alert.description,
        alert.source,
        alert.timestamp,
        alert.status,
        JSON.stringify(alert.metadata)
      ];

      await client.query(query, values);

    } catch (error) {
      logger.error('Failed to store security alert', { error, alertId: alert.id });
      throw error;
    } finally {
      client.release();
    }
  }

  async getVulnerabilities(
    status?: VulnerabilityStatus,
    severity?: VulnerabilitySeverity,
    limit: number = 100
  ): Promise<Vulnerability[]> {
    const client = await this.pool.connect();
    
    try {
      let query = `
        SELECT 
          id, cve_id as "cveId", title, description, severity, cvss_score as "cvssScore",
          component, version, fixed_version as "fixedVersion", discovered_at as "discoveredAt",
          status, assigned_to as "assignedTo", due_date as "dueDate", 
          resolved_at as "resolvedAt", resolution_notes as "resolutionNotes",
          source, references
        FROM vulnerabilities
        WHERE 1=1
      `;

      const values: any[] = [];
      let paramCount = 1;

      if (status) {
        query += ` AND status = $${paramCount++}`;
        values.push(status);
      }

      if (severity) {
        query += ` AND severity = $${paramCount++}`;
        values.push(severity);
      }

      query += ` ORDER BY cvss_score DESC, discovered_at DESC LIMIT $${paramCount}`;
      values.push(limit);

      const result = await client.query(query, values);
      
      return result.rows.map(row => ({
        ...row,
        references: JSON.parse(row.references || '[]'),
        discoveredAt: new Date(row.discoveredAt),
        resolvedAt: row.resolvedAt ? new Date(row.resolvedAt) : undefined,
        dueDate: row.dueDate ? new Date(row.dueDate) : undefined
      }));

    } catch (error) {
      logger.error('Failed to get vulnerabilities', { error });
      throw error;
    } finally {
      client.release();
    }
  }

  async updateVulnerabilityStatus(
    vulnerabilityId: string, 
    status: VulnerabilityStatus,
    assignedTo?: string,
    resolutionNotes?: string
  ): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      const query = `
        UPDATE vulnerabilities 
        SET 
          status = $1,
          assigned_to = $2,
          resolution_notes = $3,
          resolved_at = CASE WHEN $1 = 'resolved' THEN CURRENT_TIMESTAMP ELSE resolved_at END
        WHERE id = $4
      `;

      await client.query(query, [status, assignedTo, resolutionNotes, vulnerabilityId]);

      if (status === VulnerabilityStatus.RESOLVED) {
        vulnerabilitiesResolved.add(1);
      }

      logger.info('Vulnerability status updated', { 
        vulnerabilityId, 
        status, 
        assignedTo 
      });

    } catch (error) {
      logger.error('Failed to update vulnerability status', { 
        error, 
        vulnerabilityId 
      });
      throw error;
    } finally {
      client.release();
    }
  }

  async getVulnerabilityTrends(days: number = 30): Promise<Array<{
    date: string;
    critical: number;
    high: number;
    medium: number;
    low: number;
    resolved: number;
  }>> {
    const client = await this.pool.connect();
    
    try {
      const query = `
        SELECT 
          DATE(discovered_at) as date,
          COUNT(CASE WHEN severity = 'critical' THEN 1 END) as critical,
          COUNT(CASE WHEN severity = 'high' THEN 1 END) as high,
          COUNT(CASE WHEN severity = 'medium' THEN 1 END) as medium,
          COUNT(CASE WHEN severity = 'low' THEN 1 END) as low,
          COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved
        FROM vulnerabilities
        WHERE discovered_at >= CURRENT_DATE - INTERVAL '${days} days'
        GROUP BY DATE(discovered_at)
        ORDER BY date DESC
      `;

      const result = await client.query(query);
      
      return result.rows.map(row => ({
        date: row.date,
        critical: parseInt(row.critical),
        high: parseInt(row.high),
        medium: parseInt(row.medium),
        low: parseInt(row.low),
        resolved: parseInt(row.resolved)
      }));

    } catch (error) {
      logger.error('Failed to get vulnerability trends', { error });
      throw error;
    } finally {
      client.release();
    }
  }

  async generateSBOM(component: string, version: string): Promise<any> {
    try {
      logger.info('Generating SBOM', { component, version });

      // Simulate SBOM generation using Syft
      const sbom = {
        bomFormat: 'CycloneDX',
        specVersion: '1.4',
        serialNumber: `urn:uuid:${Date.now()}`,
        version: 1,
        metadata: {
          timestamp: new Date().toISOString(),
          tools: [
            {
              vendor: 'anchore',
              name: 'syft',
              version: '0.90.0'
            }
          ],
          component: {
            type: 'application',
            name: component,
            version: version
          }
        },
        components: [
          {
            type: 'library',
            name: 'express',
            version: '4.18.2',
            purl: 'pkg:npm/express@4.18.2',
            licenses: [{ license: { id: 'MIT' } }]
          },
          {
            type: 'library',
            name: 'lodash',
            version: '4.17.21',
            purl: 'pkg:npm/lodash@4.17.21',
            licenses: [{ license: { id: 'MIT' } }]
          }
        ],
        vulnerabilities: await this.getVulnerabilities(undefined, undefined, 50)
      };

      // Store SBOM
      await this.storeSBOM(component, version, sbom);

      logger.info('SBOM generated successfully', { component, version });
      return sbom;

    } catch (error) {
      logger.error('Failed to generate SBOM', { error, component, version });
      throw error;
    }
  }

  private async storeSBOM(component: string, version: string, sbom: any): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      const query = `
        INSERT INTO sboms (id, component, version, sbom_data, generated_at)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (component, version) DO UPDATE SET
          sbom_data = EXCLUDED.sbom_data,
          generated_at = EXCLUDED.generated_at
      `;

      const values = [
        `sbom-${component}-${version}-${Date.now()}`,
        component,
        version,
        JSON.stringify(sbom),
        new Date()
      ];

      await client.query(query, values);

    } catch (error) {
      logger.error('Failed to store SBOM', { error, component, version });
      throw error;
    } finally {
      client.release();
    }
  }

  async scheduleRegularScans(): Promise<void> {
    try {
      // Schedule daily scans for all repositories
      const repositories = [
        'https://github.com/aiops-platform/user-service',
        'https://github.com/aiops-platform/submission-service',
        'https://github.com/aiops-platform/analytics-service'
      ];

      for (const repo of repositories) {
        await this.scanRepository(repo);
      }

      // Schedule container scans
      const containers = [
        'aiops/user-service:latest',
        'aiops/submission-service:latest',
        'aiops/analytics-service:latest'
      ];

      for (const container of containers) {
        await this.scanContainer(container);
      }

      logger.info('Regular vulnerability scans completed');

    } catch (error) {
      logger.error('Failed to complete regular scans', { error });
      throw error;
    }
  }
}