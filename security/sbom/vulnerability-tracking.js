/**
 * SBOM Vulnerability Tracking System
 * Integrates with Trivy, Grype, and other vulnerability scanners
 * Provides real-time vulnerability tracking and alerting
 */

const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const { execSync } = require('child_process');

class SBOMVulnerabilityTracker {
  constructor(config = {}) {
    this.config = {
      sbomDirectory: config.sbomDirectory || './security/sbom/output',
      vulnerabilityDatabase: config.vulnerabilityDatabase || './security/sbom/vulnerabilities.json',
      alertWebhook: config.alertWebhook || process.env.SECURITY_ALERT_WEBHOOK,
      scanInterval: config.scanInterval || 24 * 60 * 60 * 1000, // 24 hours
      severityThresholds: {
        critical: 0,
        high: 5,
        medium: 20,
        low: 50
      },
      ...config
    };
    
    this.vulnerabilities = new Map();
    this.scanHistory = [];
    this.alertsSent = new Set();
  }

  /**
   * Initialize the vulnerability tracker
   */
  async initialize() {
    console.log('üîç Initializing SBOM Vulnerability Tracker...');
    
    // Load existing vulnerability database
    await this.loadVulnerabilityDatabase();
    
    // Start periodic scanning
    this.startPeriodicScanning();
    
    console.log('‚úÖ SBOM Vulnerability Tracker initialized');
  }

  /**
   * Load existing vulnerability database
   */
  async loadVulnerabilityDatabase() {
    try {
      const data = await fs.readFile(this.config.vulnerabilityDatabase, 'utf8');
      const database = JSON.parse(data);
      
      // Convert to Map for efficient lookups
      database.vulnerabilities.forEach(vuln => {
        this.vulnerabilities.set(vuln.id, vuln);
      });
      
      this.scanHistory = database.scanHistory || [];
      console.log(`üìä Loaded ${this.vulnerabilities.size} vulnerabilities from database`);
    } catch (error) {
      console.log('üìù Creating new vulnerability database');
      await this.saveVulnerabilityDatabase();
    }
  }

  /**
   * Save vulnerability database to disk
   */
  async saveVulnerabilityDatabase() {
    const database = {
      lastUpdated: new Date().toISOString(),
      vulnerabilities: Array.from(this.vulnerabilities.values()),
      scanHistory: this.scanHistory.slice(-100), // Keep last 100 scans
      statistics: this.generateStatistics()
    };
    
    await fs.writeFile(
      this.config.vulnerabilityDatabase,
      JSON.stringify(database, null, 2)
    );
  }

  /**
   * Scan all SBOMs for vulnerabilities
   */
  async scanAllSBOMs() {
    console.log('üîç Starting comprehensive SBOM vulnerability scan...');
    
    const scanStartTime = Date.now();
    const scanResults = {
      timestamp: new Date().toISOString(),
      scannedFiles: 0,
      newVulnerabilities: 0,
      resolvedVulnerabilities: 0,
      totalVulnerabilities: 0,
      services: {}
    };

    try {
      // Find all SBOM files
      const sbomFiles = await this.findSBOMFiles();
      console.log(`üìÅ Found ${sbomFiles.length} SBOM files to scan`);

      // Scan each SBOM file
      for (const sbomFile of sbomFiles) {
        try {
          const serviceResults = await this.scanSBOMFile(sbomFile);
          scanResults.services[serviceResults.serviceName] = serviceResults;
          scanResults.scannedFiles++;
          scanResults.newVulnerabilities += serviceResults.newVulnerabilities;
          scanResults.totalVulnerabilities += serviceResults.totalVulnerabilities;
        } catch (error) {
          console.error(`‚ùå Failed to scan ${sbomFile}:`, error.message);
        }
      }

      // Check for resolved vulnerabilities
      scanResults.resolvedVulnerabilities = await this.checkResolvedVulnerabilities();

      // Update scan history
      scanResults.duration = Date.now() - scanStartTime;
      this.scanHistory.push(scanResults);

      // Save updated database
      await this.saveVulnerabilityDatabase();

      // Check alert thresholds
      await this.checkAlertThresholds(scanResults);

      console.log(`‚úÖ Scan completed in ${scanResults.duration}ms`);
      console.log(`üìä Results: ${scanResults.newVulnerabilities} new, ${scanResults.resolvedVulnerabilities} resolved, ${scanResults.totalVulnerabilities} total`);

      return scanResults;
    } catch (error) {
      console.error('‚ùå SBOM scan failed:', error);
      throw error;
    }
  }

  /**
   * Find all SBOM files in the output directory
   */
  async findSBOMFiles() {
    const sbomFiles = [];
    
    try {
      const spdxDir = path.join(this.config.sbomDirectory, 'spdx');
      const files = await fs.readdir(spdxDir);
      
      for (const file of files) {
        if (file.endsWith('.spdx.json')) {
          sbomFiles.push(path.join(spdxDir, file));
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not read SPDX directory:', error.message);
    }

    return sbomFiles;
  }

  /**
   * Scan a single SBOM file for vulnerabilities
   */
  async scanSBOMFile(sbomFilePath) {
    const serviceName = this.extractServiceName(sbomFilePath);
    console.log(`üîç Scanning ${serviceName}...`);

    const results = {
      serviceName,
      sbomFile: sbomFilePath,
      timestamp: new Date().toISOString(),
      newVulnerabilities: 0,
      totalVulnerabilities: 0,
      vulnerabilities: []
    };

    try {
      // Use Grype to scan the SBOM
      const grypeScan = await this.runGrypeScan(sbomFilePath);
      
      // Use Trivy to scan the SBOM
      const trivyScan = await this.runTrivyScan(sbomFilePath);

      // Merge and deduplicate results
      const allVulnerabilities = this.mergeVulnerabilityResults(grypeScan, trivyScan);

      // Process each vulnerability
      for (const vuln of allVulnerabilities) {
        const vulnId = this.generateVulnerabilityId(vuln, serviceName);
        
        if (!this.vulnerabilities.has(vulnId)) {
          // New vulnerability
          const vulnerability = {
            id: vulnId,
            cve: vuln.cve,
            service: serviceName,
            package: vuln.package,
            version: vuln.version,
            severity: vuln.severity,
            description: vuln.description,
            fixedVersion: vuln.fixedVersion,
            references: vuln.references,
            firstDetected: new Date().toISOString(),
            lastSeen: new Date().toISOString(),
            status: 'open'
          };
          
          this.vulnerabilities.set(vulnId, vulnerability);
          results.newVulnerabilities++;
        } else {
          // Update existing vulnerability
          const existing = this.vulnerabilities.get(vulnId);
          existing.lastSeen = new Date().toISOString();
          existing.status = 'open';
        }
        
        results.vulnerabilities.push(vulnId);
        results.totalVulnerabilities++;
      }

      return results;
    } catch (error) {
      console.error(`‚ùå Failed to scan ${serviceName}:`, error.message);
      throw error;
    }
  }

  /**
   * Run Grype vulnerability scan
   */
  async runGrypeScan(sbomFilePath) {
    try {
      const command = `grype sbom:${sbomFilePath} -o json`;
      const output = execSync(command, { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
      const results = JSON.parse(output);
      
      return results.matches?.map(match => ({
        cve: match.vulnerability.id,
        package: match.artifact.name,
        version: match.artifact.version,
        severity: match.vulnerability.severity,
        description: match.vulnerability.description,
        fixedVersion: match.vulnerability.fix?.versions?.[0],
        references: match.vulnerability.dataSource
      })) || [];
    } catch (error) {
      console.warn(`‚ö†Ô∏è Grype scan failed for ${sbomFilePath}:`, error.message);
      return [];
    }
  }

  /**
   * Run Trivy vulnerability scan
   */
  async runTrivyScan(sbomFilePath) {
    try {
      const command = `trivy sbom ${sbomFilePath} --format json`;
      const output = execSync(command, { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
      const results = JSON.parse(output);
      
      const vulnerabilities = [];
      
      if (results.Results) {
        for (const result of results.Results) {
          if (result.Vulnerabilities) {
            for (const vuln of result.Vulnerabilities) {
              vulnerabilities.push({
                cve: vuln.VulnerabilityID,
                package: vuln.PkgName,
                version: vuln.InstalledVersion,
                severity: vuln.Severity,
                description: vuln.Description,
                fixedVersion: vuln.FixedVersion,
                references: vuln.References
              });
            }
          }
        }
      }
      
      return vulnerabilities;
    } catch (error) {
      console.warn(`‚ö†Ô∏è Trivy scan failed for ${sbomFilePath}:`, error.message);
      return [];
    }
  }

  /**
   * Merge vulnerability results from multiple scanners
   */
  mergeVulnerabilityResults(grypResults, trivyResults) {
    const merged = new Map();
    
    // Add Grype results
    grypResults.forEach(vuln => {
      const key = `${vuln.cve}-${vuln.package}-${vuln.version}`;
      merged.set(key, vuln);
    });
    
    // Add Trivy results (merge with existing)
    trivyResults.forEach(vuln => {
      const key = `${vuln.cve}-${vuln.package}-${vuln.version}`;
      if (merged.has(key)) {
        // Merge additional information
        const existing = merged.get(key);
        existing.references = [...(existing.references || []), ...(vuln.references || [])];
      } else {
        merged.set(key, vuln);
      }
    });
    
    return Array.from(merged.values());
  }

  /**
   * Generate unique vulnerability ID
   */
  generateVulnerabilityId(vulnerability, serviceName) {
    return `${serviceName}-${vulnerability.cve}-${vulnerability.package}-${vulnerability.version}`;
  }

  /**
   * Extract service name from SBOM file path
   */
  extractServiceName(sbomFilePath) {
    const filename = path.basename(sbomFilePath);
    return filename.replace(/-(source|container)\.spdx\.json$/, '');
  }

  /**
   * Check for resolved vulnerabilities
   */
  async checkResolvedVulnerabilities() {
    let resolvedCount = 0;
    const cutoffTime = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days ago
    
    for (const [id, vulnerability] of this.vulnerabilities) {
      if (vulnerability.status === 'open' && 
          new Date(vulnerability.lastSeen).getTime() < cutoffTime) {
        vulnerability.status = 'resolved';
        vulnerability.resolvedAt = new Date().toISOString();
        resolvedCount++;
      }
    }
    
    return resolvedCount;
  }

  /**
   * Check alert thresholds and send notifications
   */
  async checkAlertThresholds(scanResults) {
    const severityCounts = this.countVulnerabilitiesBySeverity();
    const alerts = [];
    
    // Check each severity threshold
    for (const [severity, threshold] of Object.entries(this.config.severityThresholds)) {
      const count = severityCounts[severity] || 0;
      if (count > threshold) {
        const alertKey = `${severity}-${count}`;
        if (!this.alertsSent.has(alertKey)) {
          alerts.push({
            severity,
            count,
            threshold,
            message: `${severity.toUpperCase()} vulnerability threshold exceeded: ${count} > ${threshold}`
          });
          this.alertsSent.add(alertKey);
        }
      }
    }
    
    // Send alerts if any
    if (alerts.length > 0) {
      await this.sendSecurityAlerts(alerts, scanResults);
    }
  }

  /**
   * Count vulnerabilities by severity
   */
  countVulnerabilitiesBySeverity() {
    const counts = { critical: 0, high: 0, medium: 0, low: 0 };
    
    for (const vulnerability of this.vulnerabilities.values()) {
      if (vulnerability.status === 'open') {
        const severity = vulnerability.severity.toLowerCase();
        if (counts.hasOwnProperty(severity)) {
          counts[severity]++;
        }
      }
    }
    
    return counts;
  }

  /**
   * Send security alerts
   */
  async sendSecurityAlerts(alerts, scanResults) {
    if (!this.config.alertWebhook) {
      console.log('‚ö†Ô∏è No alert webhook configured, skipping notifications');
      return;
    }

    const alertPayload = {
      timestamp: new Date().toISOString(),
      platform: 'AIOps Learning Platform',
      alertType: 'vulnerability_threshold_exceeded',
      severity: 'high',
      alerts,
      scanSummary: {
        totalVulnerabilities: scanResults.totalVulnerabilities,
        newVulnerabilities: scanResults.newVulnerabilities,
        scannedServices: Object.keys(scanResults.services).length
      },
      actionRequired: true,
      recommendations: [
        'Review and prioritize vulnerability remediation',
        'Update affected packages to fixed versions',
        'Consider temporary mitigations for critical vulnerabilities',
        'Schedule emergency security review if critical vulnerabilities found'
      ]
    };

    try {
      await axios.post(this.config.alertWebhook, alertPayload);
      console.log('üö® Security alerts sent successfully');
    } catch (error) {
      console.error('‚ùå Failed to send security alerts:', error.message);
    }
  }

  /**
   * Generate vulnerability statistics
   */
  generateStatistics() {
    const stats = {
      total: this.vulnerabilities.size,
      open: 0,
      resolved: 0,
      bySeverity: { critical: 0, high: 0, medium: 0, low: 0 },
      byService: {},
      oldestVulnerability: null,
      newestVulnerability: null
    };

    let oldestDate = null;
    let newestDate = null;

    for (const vulnerability of this.vulnerabilities.values()) {
      // Status counts
      if (vulnerability.status === 'open') {
        stats.open++;
      } else {
        stats.resolved++;
      }

      // Severity counts (only open vulnerabilities)
      if (vulnerability.status === 'open') {
        const severity = vulnerability.severity.toLowerCase();
        if (stats.bySeverity.hasOwnProperty(severity)) {
          stats.bySeverity[severity]++;
        }
      }

      // Service counts
      if (!stats.byService[vulnerability.service]) {
        stats.byService[vulnerability.service] = { open: 0, resolved: 0 };
      }
      stats.byService[vulnerability.service][vulnerability.status]++;

      // Date tracking
      const detectedDate = new Date(vulnerability.firstDetected);
      if (!oldestDate || detectedDate < oldestDate) {
        oldestDate = detectedDate;
        stats.oldestVulnerability = vulnerability.id;
      }
      if (!newestDate || detectedDate > newestDate) {
        newestDate = detectedDate;
        stats.newestVulnerability = vulnerability.id;
      }
    }

    return stats;
  }

  /**
   * Start periodic vulnerability scanning
   */
  startPeriodicScanning() {
    console.log(`‚è∞ Starting periodic scanning every ${this.config.scanInterval / 1000 / 60} minutes`);
    
    setInterval(async () => {
      try {
        console.log('üîÑ Starting scheduled vulnerability scan...');
        await this.scanAllSBOMs();
      } catch (error) {
        console.error('‚ùå Scheduled scan failed:', error);
      }
    }, this.config.scanInterval);
  }

  /**
   * Get vulnerability report
   */
  getVulnerabilityReport() {
    const statistics = this.generateStatistics();
    const recentScans = this.scanHistory.slice(-10);
    
    return {
      timestamp: new Date().toISOString(),
      statistics,
      recentScans,
      topVulnerabilities: this.getTopVulnerabilities(10),
      recommendations: this.generateRecommendations(statistics)
    };
  }

  /**
   * Get top vulnerabilities by severity
   */
  getTopVulnerabilities(limit = 10) {
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    
    return Array.from(this.vulnerabilities.values())
      .filter(v => v.status === 'open')
      .sort((a, b) => {
        const severityDiff = (severityOrder[b.severity.toLowerCase()] || 0) - 
                           (severityOrder[a.severity.toLowerCase()] || 0);
        if (severityDiff !== 0) return severityDiff;
        
        // Secondary sort by first detected date (oldest first)
        return new Date(a.firstDetected) - new Date(b.firstDetected);
      })
      .slice(0, limit);
  }

  /**
   * Generate security recommendations
   */
  generateRecommendations(statistics) {
    const recommendations = [];
    
    if (statistics.bySeverity.critical > 0) {
      recommendations.push({
        priority: 'critical',
        action: 'Immediate remediation required',
        description: `${statistics.bySeverity.critical} critical vulnerabilities need immediate attention`
      });
    }
    
    if (statistics.bySeverity.high > 10) {
      recommendations.push({
        priority: 'high',
        action: 'Schedule security sprint',
        description: `${statistics.bySeverity.high} high-severity vulnerabilities require prioritized remediation`
      });
    }
    
    if (statistics.open > 100) {
      recommendations.push({
        priority: 'medium',
        action: 'Review dependency management',
        description: 'High number of open vulnerabilities suggests need for better dependency hygiene'
      });
    }
    
    return recommendations;
  }
}

module.exports = SBOMVulnerabilityTracker;

// CLI usage
if (require.main === module) {
  const tracker = new SBOMVulnerabilityTracker();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'scan':
      tracker.initialize().then(() => tracker.scanAllSBOMs());
      break;
    case 'report':
      tracker.initialize().then(() => {
        const report = tracker.getVulnerabilityReport();
        console.log(JSON.stringify(report, null, 2));
      });
      break;
    case 'start':
      tracker.initialize();
      break;
    default:
      console.log('Usage: node vulnerability-tracking.js [scan|report|start]');
      console.log('  scan   - Run one-time vulnerability scan');
      console.log('  report - Generate vulnerability report');
      console.log('  start  - Start continuous monitoring');
  }
}