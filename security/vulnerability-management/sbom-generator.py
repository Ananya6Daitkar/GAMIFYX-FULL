#!/usr/bin/env python3
"""
sbom-generator.py - Software Bill of Materials (SBOM) generator for GamifyX
Generates comprehensive SBOM in SPDX and CycloneDX formats with vulnerability mapping
"""

import json
import yaml
import subprocess
import hashlib
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
import uuid
import requests
import logging
from dataclasses import dataclass, asdict
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ComponentType(Enum):
    APPLICATION = "application"
    FRAMEWORK = "framework"
    LIBRARY = "library"
    CONTAINER = "container"
    OPERATING_SYSTEM = "operating-system"
    DEVICE = "device"
    FILE = "file"

class LicenseType(Enum):
    MIT = "MIT"
    APACHE_2_0 = "Apache-2.0"
    BSD_3_CLAUSE = "BSD-3-Clause"
    GPL_3_0 = "GPL-3.0"
    LGPL_2_1 = "LGPL-2.1"
    ISC = "ISC"
    UNLICENSED = "UNLICENSED"
    UNKNOWN = "UNKNOWN"

@dataclass
class Component:
    """Represents a software component in the SBOM"""
    bom_ref: str
    type: ComponentType
    name: str
    version: str
    description: Optional[str] = None
    scope: Optional[str] = None
    hashes: Optional[List[Dict[str, str]]] = None
    licenses: Optional[List[str]] = None
    copyright: Optional[str] = None
    cpe: Optional[str] = None
    purl: Optional[str] = None
    external_references: Optional[List[Dict[str, str]]] = None
    properties: Optional[List[Dict[str, str]]] = None
    evidence: Optional[Dict[str, Any]] = None
    vulnerabilities: Optional[List[str]] = None

@dataclass
class Vulnerability:
    """Represents a vulnerability associated with a component"""
    bom_ref: str
    id: str
    source: Dict[str, str]
    references: List[Dict[str, str]]
    ratings: List[Dict[str, Any]]
    cwes: Optional[List[int]] = None
    description: Optional[str] = None
    detail: Optional[str] = None
    recommendation: Optional[str] = None
    advisories: Optional[List[Dict[str, str]]] = None
    created: Optional[str] = None
    published: Optional[str] = None
    updated: Optional[str] = None
    credits: Optional[Dict[str, List[str]]] = None
    tools: Optional[List[str]] = None
    analysis: Optional[Dict[str, Any]] = None
    affects: Optional[List[Dict[str, Any]]] = None

class SBOMGenerator:
    """Generates Software Bill of Materials for GamifyX platform"""
    
    def __init__(self, project_root: str, config_file: Optional[str] = None):
        self.project_root = Path(project_root)
        self.config = self._load_config(config_file)
        self.components: List[Component] = []
        self.vulnerabilities: List[Vulnerability] = []
        self.relationships: List[Dict[str, str]] = []
        
    def _load_config(self, config_file: Optional[str]) -> Dict[str, Any]:
        """Load SBOM generation configuration"""
        default_config = {
            "include_dev_dependencies": False,
            "include_transitive_dependencies": True,
            "include_file_hashes": True,
            "include_vulnerability_data": True,
            "output_formats": ["cyclonedx", "spdx"],
            "vulnerability_sources": ["trivy", "osv", "nvd"],
            "component_types": {
                "frontend": ComponentType.APPLICATION,
                "services": ComponentType.APPLICATION,
                "infrastructure": ComponentType.CONTAINER,
                "monitoring": ComponentType.APPLICATION
            },
            "excluded_paths": [
                "node_modules",
                ".git",
                "dist",
                "build",
                "coverage",
                "logs",
                "tmp"
            ]
        }
        
        if config_file and Path(config_file).exists():
            with open(config_file, 'r') as f:
                user_config = yaml.safe_load(f)
                default_config.update(user_config)
        
        return default_config
    
    def generate_sbom(self) -> Dict[str, Any]:
        """Generate comprehensive SBOM for the entire project"""
        logger.info("Starting SBOM generation for GamifyX platform")
        
        # Discover and analyze components
        self._discover_components()
        
        # Enrich with vulnerability data
        if self.config["include_vulnerability_data"]:
            self._enrich_with_vulnerabilities()
        
        # Generate relationships
        self._generate_relationships()
        
        # Create SBOM documents
        sbom_data = {
            "cyclonedx": self._generate_cyclonedx_sbom(),
            "spdx": self._generate_spdx_sbom()
        }
        
        logger.info(f"SBOM generation complete. Found {len(self.components)} components and {len(self.vulnerabilities)} vulnerabilities")
        
        return sbom_data
    
    def _discover_components(self):
        """Discover all components in the project"""
        logger.info("Discovering project components...")
        
        # Discover Node.js components
        self._discover_nodejs_components()
        
        # Discover Python components
        self._discover_python_components()
        
        # Discover container components
        self._discover_container_components()
        
        # Discover infrastructure components
        self._discover_infrastructure_components()
        
        # Discover system components
        self._discover_system_components()
    
    def _discover_nodejs_components(self):
        """Discover Node.js/npm components"""
        package_json_files = list(self.project_root.rglob("package.json"))
        
        for package_file in package_json_files:
            if any(excluded in str(package_file) for excluded in self.config["excluded_paths"]):
                continue
            
            try:
                with open(package_file, 'r') as f:
                    package_data = json.load(f)
                
                # Main application component
                main_component = self._create_nodejs_component(package_data, package_file)
                self.components.append(main_component)
                
                # Dependencies
                dependencies = package_data.get("dependencies", {})
                if self.config["include_dev_dependencies"]:
                    dependencies.update(package_data.get("devDependencies", {}))
                
                for dep_name, dep_version in dependencies.items():
                    dep_component = self._create_dependency_component(
                        dep_name, dep_version, "npm", package_file.parent
                    )
                    if dep_component:
                        self.components.append(dep_component)
                
                # Transitive dependencies
                if self.config["include_transitive_dependencies"]:
                    self._discover_transitive_nodejs_deps(package_file.parent)
                    
            except Exception as e:
                logger.warning(f"Error processing {package_file}: {e}")
    
    def _create_nodejs_component(self, package_data: Dict, package_file: Path) -> Component:
        """Create component from package.json data"""
        name = package_data.get("name", package_file.parent.name)
        version = package_data.get("version", "unknown")
        description = package_data.get("description", "")
        
        # Determine component type based on path
        component_type = ComponentType.APPLICATION
        if "frontend" in str(package_file):
            component_type = ComponentType.APPLICATION
        elif "services" in str(package_file):
            component_type = ComponentType.APPLICATION
        else:
            component_type = ComponentType.LIBRARY
        
        # Generate hashes if requested
        hashes = []
        if self.config["include_file_hashes"]:
            package_hash = self._calculate_file_hash(package_file)
            if package_hash:
                hashes.append({"alg": "SHA-256", "content": package_hash})
        
        # Extract license information
        licenses = []
        if "license" in package_data:
            licenses.append(package_data["license"])
        
        # Generate PURL (Package URL)
        purl = f"pkg:npm/{name}@{version}"
        
        # External references
        external_refs = []
        if "homepage" in package_data:
            external_refs.append({
                "type": "website",
                "url": package_data["homepage"]
            })
        if "repository" in package_data:
            repo_url = package_data["repository"]
            if isinstance(repo_url, dict):
                repo_url = repo_url.get("url", "")
            external_refs.append({
                "type": "vcs",
                "url": repo_url
            })
        
        return Component(
            bom_ref=f"npm-{name}-{version}",
            type=component_type,
            name=name,
            version=version,
            description=description,
            hashes=hashes if hashes else None,
            licenses=licenses if licenses else None,
            purl=purl,
            external_references=external_refs if external_refs else None,
            properties=[
                {"name": "package_manager", "value": "npm"},
                {"name": "project_path", "value": str(package_file.parent.relative_to(self.project_root))}
            ]
        )
    
    def _discover_transitive_nodejs_deps(self, project_dir: Path):
        """Discover transitive Node.js dependencies"""
        try:
            # Run npm list to get dependency tree
            result = subprocess.run(
                ["npm", "list", "--json", "--all"],
                cwd=project_dir,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                dep_tree = json.loads(result.stdout)
                self._process_dependency_tree(dep_tree.get("dependencies", {}))
                
        except Exception as e:
            logger.warning(f"Error discovering transitive dependencies in {project_dir}: {e}")
    
    def _process_dependency_tree(self, dependencies: Dict[str, Any], parent_ref: Optional[str] = None):
        """Process npm dependency tree recursively"""
        for dep_name, dep_info in dependencies.items():
            if isinstance(dep_info, dict):
                version = dep_info.get("version", "unknown")
                
                # Create component for this dependency
                component = Component(
                    bom_ref=f"npm-{dep_name}-{version}",
                    type=ComponentType.LIBRARY,
                    name=dep_name,
                    version=version,
                    scope="required",
                    purl=f"pkg:npm/{dep_name}@{version}",
                    properties=[
                        {"name": "package_manager", "value": "npm"},
                        {"name": "dependency_type", "value": "transitive"}
                    ]
                )
                
                # Check if component already exists
                if not any(c.bom_ref == component.bom_ref for c in self.components):
                    self.components.append(component)
                
                # Add relationship
                if parent_ref:
                    self.relationships.append({
                        "ref": parent_ref,
                        "dependsOn": [component.bom_ref]
                    })
                
                # Process nested dependencies
                if "dependencies" in dep_info:
                    self._process_dependency_tree(dep_info["dependencies"], component.bom_ref)
    
    def _discover_python_components(self):
        """Discover Python components"""
        requirements_files = list(self.project_root.rglob("requirements*.txt"))
        requirements_files.extend(list(self.project_root.rglob("pyproject.toml")))
        requirements_files.extend(list(self.project_root.rglob("Pipfile")))
        
        for req_file in requirements_files:
            if any(excluded in str(req_file) for excluded in self.config["excluded_paths"]):
                continue
            
            try:
                if req_file.name.startswith("requirements"):
                    self._process_requirements_txt(req_file)
                elif req_file.name == "pyproject.toml":
                    self._process_pyproject_toml(req_file)
                elif req_file.name == "Pipfile":
                    self._process_pipfile(req_file)
                    
            except Exception as e:
                logger.warning(f"Error processing {req_file}: {e}")
    
    def _process_requirements_txt(self, req_file: Path):
        """Process requirements.txt file"""
        with open(req_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    # Parse requirement line
                    if '==' in line:
                        name, version = line.split('==', 1)
                    elif '>=' in line:
                        name, version = line.split('>=', 1)
                        version = f">={version}"
                    else:
                        name, version = line, "unknown"
                    
                    component = Component(
                        bom_ref=f"pypi-{name}-{version}",
                        type=ComponentType.LIBRARY,
                        name=name.strip(),
                        version=version.strip(),
                        scope="required",
                        purl=f"pkg:pypi/{name}@{version}",
                        properties=[
                            {"name": "package_manager", "value": "pip"},
                            {"name": "requirements_file", "value": str(req_file.relative_to(self.project_root))}
                        ]
                    )
                    self.components.append(component)
    
    def _discover_container_components(self):
        """Discover container components from Dockerfiles"""
        dockerfile_patterns = ["Dockerfile*", "*.dockerfile"]
        dockerfiles = []
        
        for pattern in dockerfile_patterns:
            dockerfiles.extend(list(self.project_root.rglob(pattern)))
        
        for dockerfile in dockerfiles:
            if any(excluded in str(dockerfile) for excluded in self.config["excluded_paths"]):
                continue
            
            try:
                self._process_dockerfile(dockerfile)
            except Exception as e:
                logger.warning(f"Error processing {dockerfile}: {e}")
    
    def _process_dockerfile(self, dockerfile: Path):
        """Process Dockerfile to extract base images and components"""
        with open(dockerfile, 'r') as f:
            content = f.read()
        
        # Extract FROM statements
        from_statements = []
        for line in content.split('\n'):
            line = line.strip()
            if line.startswith('FROM '):
                image = line.split()[1]
                from_statements.append(image)
        
        # Create components for base images
        for image in from_statements:
            if ':' in image:
                name, version = image.rsplit(':', 1)
            else:
                name, version = image, "latest"
            
            component = Component(
                bom_ref=f"container-{name.replace('/', '-')}-{version}",
                type=ComponentType.CONTAINER,
                name=name,
                version=version,
                purl=f"pkg:docker/{name}@{version}",
                properties=[
                    {"name": "dockerfile", "value": str(dockerfile.relative_to(self.project_root))},
                    {"name": "component_type", "value": "base_image"}
                ]
            )
            self.components.append(component)
    
    def _discover_infrastructure_components(self):
        """Discover infrastructure components from IaC files"""
        iac_files = []
        iac_files.extend(list(self.project_root.rglob("*.tf")))
        iac_files.extend(list(self.project_root.rglob("*.yaml")))
        iac_files.extend(list(self.project_root.rglob("*.yml")))
        
        for iac_file in iac_files:
            if any(excluded in str(iac_file) for excluded in self.config["excluded_paths"]):
                continue
            
            try:
                if iac_file.suffix == '.tf':
                    self._process_terraform_file(iac_file)
                elif 'kubernetes' in str(iac_file) or 'k8s' in str(iac_file):
                    self._process_kubernetes_file(iac_file)
                elif 'docker-compose' in str(iac_file):
                    self._process_docker_compose_file(iac_file)
                    
            except Exception as e:
                logger.warning(f"Error processing {iac_file}: {e}")
    
    def _process_terraform_file(self, tf_file: Path):
        """Process Terraform file to extract infrastructure components"""
        with open(tf_file, 'r') as f:
            content = f.read()
        
        # Simple regex-based extraction (in production, use proper HCL parser)
        import re
        
        # Extract resource definitions
        resource_pattern = r'resource\s+"([^"]+)"\s+"([^"]+)"'
        resources = re.findall(resource_pattern, content)
        
        for resource_type, resource_name in resources:
            component = Component(
                bom_ref=f"terraform-{resource_type}-{resource_name}",
                type=ComponentType.APPLICATION,
                name=f"{resource_type}.{resource_name}",
                version="terraform",
                properties=[
                    {"name": "terraform_file", "value": str(tf_file.relative_to(self.project_root))},
                    {"name": "resource_type", "value": resource_type},
                    {"name": "component_type", "value": "infrastructure"}
                ]
            )
            self.components.append(component)
    
    def _discover_system_components(self):
        """Discover system-level components"""
        # Operating system
        try:
            import platform
            os_info = platform.uname()
            
            os_component = Component(
                bom_ref=f"os-{os_info.system.lower()}-{os_info.release}",
                type=ComponentType.OPERATING_SYSTEM,
                name=os_info.system,
                version=os_info.release,
                description=f"{os_info.system} {os_info.release} ({os_info.machine})",
                properties=[
                    {"name": "architecture", "value": os_info.machine},
                    {"name": "processor", "value": os_info.processor},
                    {"name": "component_type", "value": "operating_system"}
                ]
            )
            self.components.append(os_component)
            
        except Exception as e:
            logger.warning(f"Error discovering system components: {e}")
    
    def _create_dependency_component(self, name: str, version: str, package_manager: str, project_dir: Path) -> Optional[Component]:
        """Create a component for a dependency"""
        try:
            # Clean version string
            version = version.strip('^~><= ')
            
            component = Component(
                bom_ref=f"{package_manager}-{name}-{version}",
                type=ComponentType.LIBRARY,
                name=name,
                version=version,
                scope="required",
                purl=f"pkg:{package_manager}/{name}@{version}",
                properties=[
                    {"name": "package_manager", "value": package_manager},
                    {"name": "project_path", "value": str(project_dir.relative_to(self.project_root))}
                ]
            )
            
            return component
            
        except Exception as e:
            logger.warning(f"Error creating component for {name}@{version}: {e}")
            return None
    
    def _enrich_with_vulnerabilities(self):
        """Enrich components with vulnerability data"""
        logger.info("Enriching SBOM with vulnerability data...")
        
        # Load vulnerability data from various sources
        vuln_data = {}
        
        # Load Trivy results
        trivy_results = self._load_trivy_vulnerabilities()
        if trivy_results:
            vuln_data.update(trivy_results)
        
        # Load OSV data
        osv_results = self._load_osv_vulnerabilities()
        if osv_results:
            vuln_data.update(osv_results)
        
        # Map vulnerabilities to components
        for component in self.components:
            component_vulns = vuln_data.get(component.bom_ref, [])
            if component_vulns:
                component.vulnerabilities = [v["id"] for v in component_vulns]
                
                # Add vulnerability objects
                for vuln_data_item in component_vulns:
                    vulnerability = self._create_vulnerability_object(vuln_data_item, component)
                    self.vulnerabilities.append(vulnerability)
    
    def _load_trivy_vulnerabilities(self) -> Dict[str, List[Dict]]:
        """Load vulnerability data from Trivy scan results"""
        trivy_file = self.project_root / "security" / "reports" / "trivy-report.json"
        
        if not trivy_file.exists():
            logger.warning("Trivy report not found, skipping vulnerability enrichment")
            return {}
        
        try:
            with open(trivy_file, 'r') as f:
                trivy_data = json.load(f)
            
            vuln_map = {}
            
            for result in trivy_data.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    pkg_name = vuln.get("PkgName", "")
                    pkg_version = vuln.get("InstalledVersion", "")
                    
                    # Find matching component
                    component_ref = None
                    for component in self.components:
                        if component.name == pkg_name and component.version == pkg_version:
                            component_ref = component.bom_ref
                            break
                    
                    if component_ref:
                        if component_ref not in vuln_map:
                            vuln_map[component_ref] = []
                        
                        vuln_map[component_ref].append({
                            "id": vuln.get("VulnerabilityID", ""),
                            "source": "trivy",
                            "severity": vuln.get("Severity", "UNKNOWN"),
                            "cvss_score": vuln.get("CVSS", {}).get("nvd", {}).get("V3Score", 0.0),
                            "description": vuln.get("Description", ""),
                            "fixed_version": vuln.get("FixedVersion", ""),
                            "references": vuln.get("References", [])
                        })
            
            return vuln_map
            
        except Exception as e:
            logger.warning(f"Error loading Trivy vulnerabilities: {e}")
            return {}
    
    def _load_osv_vulnerabilities(self) -> Dict[str, List[Dict]]:
        """Load vulnerability data from OSV (Open Source Vulnerabilities)"""
        # This would query the OSV API for vulnerability data
        # For now, return empty dict
        return {}
    
    def _create_vulnerability_object(self, vuln_data: Dict, component: Component) -> Vulnerability:
        """Create a vulnerability object from vulnerability data"""
        vuln_id = vuln_data.get("id", "")
        
        # Create ratings
        ratings = []
        if vuln_data.get("cvss_score"):
            ratings.append({
                "source": {"name": vuln_data.get("source", "unknown")},
                "score": vuln_data["cvss_score"],
                "severity": vuln_data.get("severity", "UNKNOWN"),
                "method": "CVSSv3",
                "vector": ""
            })
        
        # Create references
        references = []
        for ref in vuln_data.get("references", []):
            references.append({
                "id": ref,
                "source": {"name": "reference", "url": ref}
            })
        
        # Create affects
        affects = [{
            "ref": component.bom_ref,
            "versions": [{
                "version": component.version,
                "status": "affected"
            }]
        }]
        
        if vuln_data.get("fixed_version"):
            affects[0]["versions"].append({
                "version": vuln_data["fixed_version"],
                "status": "unaffected"
            })
        
        return Vulnerability(
            bom_ref=f"vuln-{vuln_id}",
            id=vuln_id,
            source={"name": vuln_data.get("source", "unknown")},
            references=references,
            ratings=ratings,
            description=vuln_data.get("description", ""),
            recommendation=f"Update to version {vuln_data.get('fixed_version', 'latest')}" if vuln_data.get("fixed_version") else "No fix available",
            created=datetime.now(timezone.utc).isoformat(),
            affects=affects
        )
    
    def _generate_relationships(self):
        """Generate component relationships"""
        # This would analyze dependencies and create relationship mappings
        # For now, we'll create basic relationships based on project structure
        
        # Find main application components
        main_components = [c for c in self.components if c.type == ComponentType.APPLICATION]
        library_components = [c for c in self.components if c.type == ComponentType.LIBRARY]
        
        # Create dependencies from applications to libraries
        for main_comp in main_components:
            dependencies = []
            
            # Find related libraries based on project path
            main_path = None
            for prop in main_comp.properties or []:
                if prop["name"] == "project_path":
                    main_path = prop["value"]
                    break
            
            if main_path:
                for lib_comp in library_components:
                    lib_path = None
                    for prop in lib_comp.properties or []:
                        if prop["name"] == "project_path":
                            lib_path = prop["value"]
                            break
                    
                    if lib_path and lib_path.startswith(main_path):
                        dependencies.append(lib_comp.bom_ref)
            
            if dependencies:
                self.relationships.append({
                    "ref": main_comp.bom_ref,
                    "dependsOn": dependencies
                })
    
    def _generate_cyclonedx_sbom(self) -> Dict[str, Any]:
        """Generate SBOM in CycloneDX format"""
        sbom = {
            "bomFormat": "CycloneDX",
            "specVersion": "1.5",
            "serialNumber": f"urn:uuid:{uuid.uuid4()}",
            "version": 1,
            "metadata": {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "tools": [
                    {
                        "vendor": "GamifyX",
                        "name": "SBOM Generator",
                        "version": "1.0.0"
                    }
                ],
                "component": {
                    "type": "application",
                    "bom-ref": "gamifyx-platform",
                    "name": "GamifyX AIOps Learning Platform",
                    "version": "1.0.0",
                    "description": "Cyberpunk-themed AIOps learning platform with gamification"
                }
            },
            "components": [asdict(comp) for comp in self.components],
            "dependencies": self.relationships
        }
        
        # Add vulnerabilities if present
        if self.vulnerabilities:
            sbom["vulnerabilities"] = [asdict(vuln) for vuln in self.vulnerabilities]
        
        return sbom
    
    def _generate_spdx_sbom(self) -> Dict[str, Any]:
        """Generate SBOM in SPDX format"""
        sbom = {
            "spdxVersion": "SPDX-2.3",
            "dataLicense": "CC0-1.0",
            "SPDXID": "SPDXRef-DOCUMENT",
            "name": "GamifyX-SBOM",
            "documentNamespace": f"https://gamifyx.com/sbom/{uuid.uuid4()}",
            "creationInfo": {
                "created": datetime.now(timezone.utc).isoformat(),
                "creators": ["Tool: GamifyX-SBOM-Generator"],
                "licenseListVersion": "3.19"
            },
            "packages": [],
            "relationships": []
        }
        
        # Convert components to SPDX packages
        for i, component in enumerate(self.components):
            package = {
                "SPDXID": f"SPDXRef-Package-{i}",
                "name": component.name,
                "downloadLocation": "NOASSERTION",
                "filesAnalyzed": False,
                "copyrightText": component.copyright or "NOASSERTION"
            }
            
            if component.version:
                package["versionInfo"] = component.version
            
            if component.licenses:
                package["licenseConcluded"] = component.licenses[0]
                package["licenseDeclared"] = component.licenses[0]
            else:
                package["licenseConcluded"] = "NOASSERTION"
                package["licenseDeclared"] = "NOASSERTION"
            
            if component.description:
                package["description"] = component.description
            
            if component.external_references:
                package["homepage"] = component.external_references[0].get("url", "NOASSERTION")
            
            sbom["packages"].append(package)
        
        # Convert relationships
        for rel in self.relationships:
            for dep in rel.get("dependsOn", []):
                sbom["relationships"].append({
                    "spdxElementId": f"SPDXRef-{rel['ref']}",
                    "relationshipType": "DEPENDS_ON",
                    "relatedSpdxElement": f"SPDXRef-{dep}"
                })
        
        return sbom
    
    def _calculate_file_hash(self, file_path: Path) -> Optional[str]:
        """Calculate SHA-256 hash of a file"""
        try:
            with open(file_path, 'rb') as f:
                file_hash = hashlib.sha256()
                for chunk in iter(lambda: f.read(4096), b""):
                    file_hash.update(chunk)
                return file_hash.hexdigest()
        except Exception as e:
            logger.warning(f"Error calculating hash for {file_path}: {e}")
            return None
    
    def save_sbom(self, output_dir: str, formats: Optional[List[str]] = None):
        """Save SBOM to files"""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        formats = formats or self.config["output_formats"]
        sbom_data = self.generate_sbom()
        
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        
        for format_name in formats:
            if format_name in sbom_data:
                filename = f"gamifyx-sbom-{timestamp}.{format_name}.json"
                filepath = output_path / filename
                
                with open(filepath, 'w') as f:
                    json.dump(sbom_data[format_name], f, indent=2, default=str)
                
                logger.info(f"SBOM saved to {filepath}")
        
        # Generate summary report
        self._generate_summary_report(output_path, timestamp)
    
    def _generate_summary_report(self, output_path: Path, timestamp: str):
        """Generate SBOM summary report"""
        summary = {
            "generation_timestamp": datetime.now(timezone.utc).isoformat(),
            "project_name": "GamifyX AIOps Learning Platform",
            "total_components": len(self.components),
            "total_vulnerabilities": len(self.vulnerabilities),
            "component_breakdown": {},
            "vulnerability_breakdown": {},
            "license_breakdown": {},
            "high_risk_components": []
        }
        
        # Component breakdown by type
        for component in self.components:
            comp_type = component.type.value
            summary["component_breakdown"][comp_type] = summary["component_breakdown"].get(comp_type, 0) + 1
        
        # Vulnerability breakdown by severity
        for vuln in self.vulnerabilities:
            for rating in vuln.ratings:
                severity = rating.get("severity", "UNKNOWN")
                summary["vulnerability_breakdown"][severity] = summary["vulnerability_breakdown"].get(severity, 0) + 1
        
        # License breakdown
        for component in self.components:
            if component.licenses:
                for license_name in component.licenses:
                    summary["license_breakdown"][license_name] = summary["license_breakdown"].get(license_name, 0) + 1
        
        # High-risk components (components with critical vulnerabilities)
        for component in self.components:
            if component.vulnerabilities:
                # Check if any vulnerability is critical
                for vuln in self.vulnerabilities:
                    if vuln.id in component.vulnerabilities:
                        for rating in vuln.ratings:
                            if rating.get("severity") == "CRITICAL":
                                summary["high_risk_components"].append({
                                    "name": component.name,
                                    "version": component.version,
                                    "type": component.type.value,
                                    "vulnerabilities": component.vulnerabilities
                                })
                                break
        
        # Save summary report
        summary_file = output_path / f"gamifyx-sbom-summary-{timestamp}.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2, default=str)
        
        logger.info(f"SBOM summary report saved to {summary_file}")

def main():
    """Main function for CLI usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate Software Bill of Materials (SBOM) for GamifyX")
    parser.add_argument("--project-root", default=".", help="Project root directory")
    parser.add_argument("--config", help="Configuration file path")
    parser.add_argument("--output-dir", default="security/sbom", help="Output directory for SBOM files")
    parser.add_argument("--formats", nargs="+", choices=["cyclonedx", "spdx"], 
                       default=["cyclonedx", "spdx"], help="Output formats")
    parser.add_argument("--include-dev", action="store_true", help="Include development dependencies")
    parser.add_argument("--include-vulns", action="store_true", default=True, help="Include vulnerability data")
    
    args = parser.parse_args()
    
    # Create SBOM generator
    generator = SBOMGenerator(args.project_root, args.config)
    
    # Override config with CLI arguments
    if args.include_dev:
        generator.config["include_dev_dependencies"] = True
    if not args.include_vulns:
        generator.config["include_vulnerability_data"] = False
    
    # Generate and save SBOM
    try:
        generator.save_sbom(args.output_dir, args.formats)
        logger.info("SBOM generation completed successfully")
    except Exception as e:
        logger.error(f"SBOM generation failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()